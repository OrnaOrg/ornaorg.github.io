<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="description" content="Atomic CSS model and tools">
    <meta name="keywords" content="Atomic, CSS, Model, Tools, Orna, Atomizer, Web">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Atomic CSS</title>
    <script src="jquery-1.12.0.js"></script>
    <script src="orna.js"></script>
<script type="text/javascript" src="//vk.com/js/api/openapi.js?121"></script>
<script type="text/javascript">
  VK.init({apiId: 5275263, onlyWidgets: true});
</script>
</head>
<body class="bgc_rgb(220,220,220) bgi_url(img/atom.png)">
    <div class="width_650px  margin_auto color_#ee0645_h2 bgc_rgb(240,240,240) padding_40px bgc_skyblue_code arial padding_10px_code border_2px_solid_gray ">
        
        <i>Дима Попов, 2016 <a href="https://github.com/OrnaOrg">OrnaOrg</a></i>
        <br>
        <h1>Atomic CSS</h1>
        <hr>
        <br>
        <strong>Atomic СSS</strong> - это модель построения <a href="https://ru.wikipedia.org/wiki/CSS">CSS</a> кода, при которой почти каждому СSS свойству соответствует свой класс.<br> Atomic CSS активно разрабатывается командой Atomizer, Orna, Yahoo и одинокими рейнджерами-программистами. 

        <h2>Плюсы перед семантической моделью (классической).</h2> 

        <h3>1. Независимость от имен. (Универсальность имен).</h3> 

В атомном классе имя в принципе не несет семантического (указательного) значения, а css значение и свойство. Поэтому вы можете применять его везде, без разрушения логики. 
То есть, если у вас есть класс .button (кнопка), то его не корректно применять например к форме. 

        <h3>2. Универсальность классов.</h3> 

Так как классы не только имеют универсальное имя, но и одно значения (не всегда одно), при создании небольшого количества таких классов вы можете иметь большое число комбинаций. 
<br>
Для чайников: элементам можно задавать по несколько классов. Вы можете создавать классные вещи комбинацией уже описанных классов, а не их созданием. 

        <h3>3. Читабельность классов (При правильной организации, конечно же).</h3> 

Если человек видит класс с названием width100px, он сразу поймет что он задает, не смотря в код. 

        <h2>FAQ (Ответы):</h2> 

        <h3>1. Чем это не inline верстка в атрибуте style?</h3> 

На первый взгляд может возникнуть такой вопрос, и можно подумать что это то же самое, но это только на первый взгляд. 
Разница в том, что инлайн стили не кэшируются, имеют большой приоритет и сложный доступ, что очень усложняет роботу с ними и их динамическую замену. 

<h3>2. Чем это удобно, если очень много нужно писать классов в элемент?</h3> 

Реально при создании одного класса и задания ему свойств вы пишете меньше чем когда бы задавали их прямо в элементе, вам ведь еще нужно каждому атомарному классу селектор и скобки дописать. Это можно не делать, и свойства не дублировать, потому что есть крутые инструменты (Atomizer и Orna) для работы с атомарным css, о которых я дальше расскажу. 

        <h3>3. А если у вас много одинаковых элементов ваш atomic сss сдуется, пфф?</h3>

Это опять же только на первый взгляд, и ничего не сдуется. 
Для начала разберемся, если вы вашим одинаковым элементам задаете класс, вам нечего не стоит записать несколько классов. 
        <h4>А если их очень много и если вдруг нужно их все сразу изменить?</h4>

Если будет нужно изменить пачку элементов, может возникнут трудность, когда не грамотно построена атомная модель. 

Что бы это хорошо решить, можно затянуть все эти элементы в родительский и в родительском записать стили, но для всех выбранных дочерних элементов. 
<br>
Можно с помощью javascript выборки задать группе элементов определенные классы, но при таком подходе есть нюанс о котором походу. 
<br>
Еще метод решения этой задачи подключить css препроцессор, эта часть для понимающих. 
В общем, подключить препроцессор, создать в нем атомные классы, а потом вывести их как примеси в один и задать этой группе элементов. Да, при работе с препроцессорами также можно опираться на атомарною модель! Кстати препроцессоры очень для этого хороши, потому, как в большинство из них, уже вынесены решения из атомарной css. Но это не атомарный css, в них также есть те проблемы, что и в css, проблема с семантикой имен, которая пущена на произвол пользователя и наследование, что также пущено на произвол, и из-за этого, даже опытные разработчики, бывает, загоняют себе в тупик. Только не надо писать что это из-за того, что руки не истого места растут, и что с вами такого никогда не было. 

        <h3>4. Что будет если макет предназначен только для обвертки мощной Backend части, не будет ли избыток классов в html или другой разметке мешать Backend программистам?</h3>

Что можно сказать, будет, а если нет то у вас золотой Backend программист, но если он такой, все равно не надо усложнять ему жизнь. Для того чтобы не усложнять ему жизнь нужно или расспросить Backend программиста какую разметку он хочет видеть и от этого уже плясать, или все грамотно продумать чтобы все было чисто и удобно вам и ему. Это реально если продумать и если кто не знал над css тоже надо подумать и сделать рефакторинг. 

        <h3>5. Кто использует эту модель?(human proves)</h3>

        Открою вам секрет отчасти почти все. То бишь создание примесей в препроцессорах типа <a href="http://lesscss.org">Less</a>, создание хотя бы одного класса с одним значением и логичным названием уже атомарный CSS, то что почти все используют можно доказать если создать поиск в github по коду. Фул стеково, то есть полностью по ней пишут многие, но это совсем не обязательно! Это надо понимать, вообще фул стековая верстка на любом, может бить не удобной в определенных моментах. 
Не надо все возводить в абсолют. 

        <p>Ближе к делу!!!</p> 

        <strong>Как выглядит атомарный класс.</strong>
        <br><br>
<code>
.width100px{ 
width: 100px; 
} 
<br>
<br>
.width100\%{ 
width: 100%; 
} 
        </code>
        <br><br>
        <strong>Варианты:</strong> width100px, width-100px, w100px, w-100px, wh100px, wh-100px и т.д. <br>
Можно писать, как вам удобно, но чтоб это передавало свойство. События делаются обычными псевдоклассами: hover, focus, active. 

        <h2>Инструменты для работы с Atomic CSS.</h2> 
        <h3>Orna и Atomizer</h3> 

        <a href="http://acss.io"><strong>Atomizer</strong></a> – <a href="https://nodejs.org">node.js</a> модуль для создания Atomic CSS от Yahoo. 
<br>
<br>
        <strong>Как он работает?</strong> 
        Вы пишете <a href="https://ru.wikipedia.org/wiki/HTML">html</a> разметку и в элементах пишете атомарные классы по структуре атомайзера. Атомайзер считывает документ и создает atomic.css файл с классами названия которых были прописаны в атрибутах class. 
<br>
<br>
        <strong>Пример:</strong><br>
<br>
<code>
class="Bgc(#0280ae.5) C(#fff) P(20px)"	
        </code>
        <ol>
При таком подходе: 
           <br>
           <br>
            <li>Все классы не inline style, если вы не понимаете разницу посмотрите <a href="https://www.w3.org/Style/CSS/specs.ru.html">спецификацию CSS</a>.</li>
            <li>Нет ненужных классов.</li> 
        </ol>
            <p><strong>Рекомендация:</strong> Atomizer хорош для больших сайтов, все компилируется в отдельный файл css, но сначала немного сложен.</p> 

<a href="http://acss.io">acss.io</a> 
<br>
<br>
           <hr>
           <br>
            <a href="http://ornaorg.github.io"><strong>Orna (OrnaJS)</strong></a> – javascript парсер на основе jquery, который работает в браузере на стороне клиента и подключается непосредственно в документ. В отличии от Атомайзера, который не подключается в документ, а подключается ранее сгенерированный им css файл. 
Классы Орна пишутся по определенной структуре, которая почти и местами вообще не отличается от css. Орна задает классы напрямую элементам без файла css. Вот и нюанс c js, классы задание ним не кэшируються и переопределяются с перезагрузкой страницы. Но это хорошо для динамики. По сути Орна это генератор атомарных классов. Супер для работы с <a href="https://facebook.github.io/react">ReactJS</a> и <a href="http://handlebarsjs.com">Handlebars.JS</a>. Есть также версия Орны для Node.js (<a href="http://ornaorg.github.io/Orna4Node.html">Orna4Node</a>), которая генерирует классы в CSS файл, как <a href="http://acss.io">Atomizer</a>.
<br><br>
            <strong>Пример:</strong><br> 
<br>
<code>
class="background-color_red background-color_black_click color_white height_100px"
        </code>
        <br>
        <br>
        или
        <br>
        <br>
        <code>
class="bgc_red bgc_black_click c_white h_100px"
        </code>
        <br>
        <br>
        Орна поймет оба примера!
        <br>
<ol>
   При таком подходе: 
   <br>
   <br>
    <li>Всегда можно изменить классы и Орна их считает, не нужно писать сss.</li> 
    <li>Можно легко динамически изменять классы и рендерит как все так и определение элементы отдельно.</li>
        </ol>
            <p><strong>Рекомендация:</strong> Орна парсит документ каждый раз при перезагрузке страницы, файлы не кэшируются, потому она лучше для небольших сайтов или как дополнение.</p>

<a href="http://ornaorg.github.io">ornaorg.github.io</a> 
<br>
<br>

            <i>!!! Orna и Atomizer умеют работать с событиями мыши и дочерними элементами через родительский.</i>

            <p><strong>Общая рекомендация:</strong> разберитесь в Atomic CSS, не устраивайте холивары и пишите свое адекватное мнение в комментарии.<br> Хороший комплект для работы и динамического рендера(отрисовки) страницы: OrnaJS + ReactJS. Предварительное создание CSS: Orna4Node или Atomizer. </p> 

Дополнение: 
<br>
<br>
<a href="http://www.creativebloq.com/css3/atomic-css-11619006">==1==</a> 
<a href="https://www.lucidchart.com/techblog/2014/01/31/atomic..">==2==</a>
<a href="https://www.haikudeck.com/atomic-css-science-and-technology-presentation-dJ0xlFjhBQ">==3==</a>
<a href="http://www.cssmojo.com/atomic-css-on-steroids/">==4==</a>
<a href="http://www.prowebdesign.ro/tag/atomic-css/">==5==</a>
        <br>
        <br>
        <div id="vk_comments"></div>
<script type="text/javascript">
VK.Widgets.Comments("vk_comments", {limit: 10, width: "665", attach: "*"});
</script>
       
        
    </div>
</body>
</html>